[{"title":"Hello World","url":"/2022/02/23/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["test"],"tags":["hello"]},{"title":"Java的安装和环境配置","url":"/2022/03/03/Java%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"Java的安装和环境配置\nJava Downloads | Oracle\n去Oracle官网，找到Java下载\n\n选择Java8下载JDK8\nx86表示适用于32位的电脑，x64适用于64位的电脑\n需要先登录账号才能下载，如果没有账号就需要注册一个。\n下载完之后双击安装\n记住选择安装的路径\n如果是默认安装路径，应该是C:\\Program Files\\Java\n\n设置→\n\n\n\n\n新建系统变量，变量名为JAVA_HOME，变量值为JDK的安装根目录\n\n也就是这里\n\n编辑PATH\n\n\n编辑PATH变量，将刚刚新建的JAVA_HOME变量加上bin目录设置到PATH\n\n或者是这种形式的\n\n把%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;加到后面就行，注意不要漏掉分号。\nwin+R打开cmd\n\n在命令行中分别输入java -version ,java,javac，若都出现下面，说明已安装成功。\n\n\n​    \n","tags":["Java"]},{"title":"Android Studio两个gradle文件","url":"/2022/03/03/Android-Studio%E4%B8%A4%E4%B8%AAgradle%E6%96%87%E4%BB%B6/","content":"Android Studio 是用gradle来构建项目的。创建项目时会有两个build.gradle文件，一个在最外层，一个在app目录下。\n\n最外层目录的build.gradle：// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123;    repositories &#123;        google()        mavenCentral()    &#125;    dependencies &#123;        classpath &quot;com.android.tools.build:gradle:7.0.4&quot;        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.10&quot;        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    &#125;&#125;task clean(type: Delete) &#123;    delete rootProject.buildDir&#125;\n\n\n\nrepositoriesrepositories的闭包中声明了   google() mavenCentral()，两者分别对应了一个代码仓库，google仓库中包含的主要是Google的扩展依赖库，mavenCentral仓库中是一些第三方开源库，声明两行配置后项目可以引用Google和mavenCentral仓库中的依赖库。\nrepositories &#123;    google()    mavenCentral()&#125;\n\n\nmaven仓库有两种，mavenCenter()和jCenter():\n\nMaven Central 则是由sonatype.org维护的Maven仓库。\n\nhttp://jcenter.bintray.com/\n\njcenter是一个由 bintray.com维护的Maven仓库。可以在这里看到整个仓库的内容。\n\n https://oss.sonatype.org/content/repositories/releases/\n\nmaven中央仓库已经将内容浏览功能禁掉了，可在这个网站查询。\n\n http://search.maven.org/\nJCenter() 与 mavenCenter()在完全不同的服务器上维护，由不同的人提供内容，两者之间毫无关系。在jcenter上有的可能 Maven Central 上没有，反之亦然。\n\ndependenciesdependencies闭包中使用classpath声明了两个插件：一个Gradle插件和一个Kotlin插件。如果想要Gradle来构建Android项目，要声明这个插件。用Kotlin插件表示目前项目是用Kotlin开发，如果是Java版的Android项目就不需要声明这个Kotlin插件。\ndependencies &#123;\n    classpath &quot;com.android.tools.build:gradle:7.0.4&quot;\n    classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.10&quot;\n&#125;\n\napp目录下的build.gradle文件：plugins &#123;    id &#x27;com.android.application&#x27;    id &#x27;kotlin-android&#x27;&#125;android &#123;    compileSdk 31    defaultConfig &#123;        applicationId &quot;com.example.kotlinpractice&quot;        minSdk 21        targetSdk 32        versionCode 1        versionName &quot;1.0&quot;        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;    &#125;    buildTypes &#123;        release &#123;            minifyEnabled false            proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27;        &#125;    &#125;    compileOptions &#123;        sourceCompatibility JavaVersion.VERSION_1_8        targetCompatibility JavaVersion.VERSION_1_8    &#125;    kotlinOptions &#123;        jvmTarget = &#x27;1.8&#x27;    &#125;&#125;dependencies &#123;    implementation &#x27;androidx.core:core-ktx:1.3.2&#x27;    implementation &#x27;androidx.appcompat:appcompat:1.2.0&#x27;    implementation &#x27;com.google.android.material:material:1.3.0&#x27;    implementation &#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;    testImplementation &#x27;junit:junit:4.+&#x27;    androidTestImplementation &#x27;androidx.test.ext:junit:1.1.2&#x27;    androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.3.0&#x27;&#125;\n\npluginsplugins &#123;    id &#x27;com.android.application&#x27;    id &#x27;kotlin-android&#x27;&#125;\n\n此处用了两个插件，com.android.application表示这是一个应用程序模块，这里还可以选一个值：com.android.library，表示这是一个库模块。二者最大区别是应用程序模块是可以直接运行的，库模块只能作为代码库依附于别的应用程序模块来运行。\n第二个插件kotlin-android，如果用kotlin开发Android项目，这个插件是必须的。\nandroid compileSdk 31用于指定项目编译版本，这里31表示用Android 12.0系统的SDK编译。\n\ndefaultConfig闭包\napplicationId每一个应用的唯一标识符，绝对不能重复，默认使用创建项目时候的包名，后面想改可以在这里改。\nminSdk用于指定项目最低兼容的Android版本，指定为21说明最低兼容到Android 5.0\ntargetSdk\nversionCode项目版本号\nversionName项目版本名\ntestInstrumentationRunner在当前项目中启用JUnit测试。可以为当前项目编写测试用例。\n\nbuildTypes闭包用于指定生成安装文件的相关配置，通常有两个子闭包：debug 、release\n\ndebug 用于指定生成测试版安装文件的配置，可以忽略不写\n\nrelease用于指定生成正式版安装文件的配置。\nrelease闭包中的具体内容\n\nminifyEnabled 用于指定是否对项目代码进行混淆，true：混淆   false：不混淆\n\nproguardFiles用于指定混淆时使用的规则文件，这里指定两个文件\n\nproguard-android-optimize.txt在&#x2F;tools&#x2F;proguard目录下的里面是所有项目通用混淆规则\nproguard-rules.pro在当前项目下，可以编写当前项目特有的混淆规则\n\n\n\n\n通过Android Studio直接运行项目生成的都是测试版安装文件\n\n\ndependencies闭包指定当前项目所有依赖关系\n一般Android Studio有三种依赖方式：本地依赖、远程依赖、库依赖\n\n本地依赖：对本地jar包或目录添加依赖关系\n库依赖：对项目中的库模块添加依赖\n远程依赖：可以对jcenter仓库上的开源项目添加依赖关系\n\n参考：《第一行代码》、JCenter() 与 mavenCenter() 的区别_小二的茶馆-CSDN博客_jcenter\n","tags":["Android"]},{"title":"Android Studio 修改包名","url":"/2022/04/01/Android-Studio-%E4%BF%AE%E6%94%B9%E5%8C%85%E5%90%8D/","content":"找到清单文件\n\n找到package\n\n选中中间那个example，右键，Refactor，Rename，或者直接shift+F6\n\n点击rename package\n\n出现这个界面，就可以重命名包名了\n\n改完发现并没有那么简单，例如R文件的引用出问题了，还是com.example.XX\n修改app里面的build.gradle的applicationId\n\n改完这个之后那个import R Class就变成修改后的包名了\n\nAndroidManifest.xml 清单文件中注册的所有 Activity , Service 等组件 , 其 android:name 属性 , 都使用该组件的完整的包名类名，避免使用缺省包名的形式\n像这样\n\n包名修改后 , 对应生成的资源类 R , 编译配置类 BuildConfig 的包名也发生了相应的改变 ;\n对于源码中修改的 R 较多时 , 选中源码目录 src , 使用 “ Ctrl + Shift + R “ 快捷键 , 也可以右键点击 src 目录 , 选择 “ Replace in Path… “ 选项 ,\n修改 R 资源引用 : 在 “ Replace in Path “ 对话框中 ,\n搜索 “import kim.hsl.package_change.R;”替换为 “import kim.hsl.package_change2.R;”\n直接点击下方的 “ Replace All “ 按钮 , 替换工程中所有的导入选项即可 ;\n参考：【Android 应用开发】Android 工程修改包名流程 ( 修改 applicationId | 修改 package | 修改 R 资源引用 | 修改 BuildConfig 引用 )_让 学习 成为一种 习惯 ( 韩曙亮 の 技术博客 )-CSDN博客_android 修改包名\n","tags":["Android Studio"]},{"title":"数据结构（一）线性表","url":"/2022/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/","content":"线性结构：基本特点是除第一个元素无直接前驱，最后一个元素无直接后继之外，其他每个数据元素都有一个前驱和后继。线性表、栈、队列、串和数组都属于线性结构\n线性表\n（A，B，C，…，Z）\n是一个线性表，表中的数据元素是单个字母。在稍复杂的线性表中，一个数据元素可以包含若干个数据项\n诸如此类由n（n≥0）个数据特性相同的元素构成的有限序列称为线性表。\n对于非空的线性表或线性结构，其特点是：\n（1）存在唯一的一个被称作“第一个”的数据元素；\n（2）存在唯一的一个被称作“最后一个”的数据元素；\n（3）除第一个之外，结构中的每个数据元素均只有一个前驱；\n（4）除最后一个之外，结构中的每个数据元素均只有一个后继\n线性表的顺序存储表示\n线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为顺序表（Sequential List）。其特点是，逻辑上相邻的数据元素，其物理次序也是相邻的。\n假设线性表的每个元素需占用l个存储单元,线性表的第i个数据元素ai的存储位置为\nLOC(ai)=LOC(a1)+(i−1) × l\n\nLOC(a1)是线性表的第一个数据元素a1的存储位置，通常称作线性表的起始位置或基地址,表中相邻的元素ai和ai+1的存储位置LOC(ai)和LOC(ai+1)是相邻的.\n每一个数据元素的存储位置都和线性表的起始位置相差一个常数，这个常数和数据元素在线性表中的位序成正比（见图2.2）。由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。\n高级程序设计语言数组类型也有随机存取的特性，因此，通常都用数组来描述数据结构中的顺序存储结构\nC语言中可用动态分配的一维数组表示线性表\n\n\n将L定义为SqList类型的变量，便可以利用L.elem[i-1]访问表中位置序号为i的的图书记录。\n老熟人了。Java里面有List\n当线性表以上述定义的顺序表表示时，某些操作很容易实现。因为表的长度是顺序表的一个“属性”，所以可以通过返回length的值实现求表长的操作，通过判断length的值是否为0判断表是否为空，这些操作算法的时间复杂度都是O(1)。\n\n动态分配线性表的存储区域可以更有效地利用系统的资源，当不需要该线性表时，可以使用销毁操作及时释放占用的存储空间。\n2．取值\n取值操作是根据指定的位置序号i，获取顺序表中第i个数据元素的值。由于顺序存储结构具有随机存取的特点，可以直接通过数组下标定位得到，elem[i-1]单元存储第i个数据元素。\n顺序表取值算法的时间复杂度为O(1)。\n\n查找操作是根据指定的元素值e，查找顺序表中第1个与e相等的元素。若查找成功，则返回该元素在表中的位置序号；若查找失败，则返回0\n\n顺序表的查找\n① 从第一个元素起，依次和e相比较，若找到与e相等的元素L.elem[i]，则查找成功，返回该元素的序号i+1。② 若查遍整个顺序表都没有找到，则查找失败，返回0。\n在查找时，为确定元素在顺序表中的位置，需和给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的平均查找长度（Average Search Length，ASL）。\n顺序表按值查找算法的平均时间复杂度为O(n)。\n4．插入\n线性表的插入操作是指在表的第i个位置插入一个新的数据元素e，使长度为n的线性表\n(a1,…,ai−1,ai,…,an)\n变成长度为n+1的线性表\n(a1,…,ai−1,e, ai,…,an)\n数据元素ai−1和ai之间的逻辑关系发生了变化。\n由于逻辑上相邻的数据元素在物理位置上也是相邻的，因此，除非i&#x3D;n+1，否则必须移动元素才能反映这个逻辑关系的变化。【i&#x3D;n+1也就是在最后一个插入】\n在第i（1≤i≤n）个位置插入一个元素时，需从最后一个元素即第n个元素开始，依次向后移动一个位置，直至第i个元素（共n−i+1个元素）。\n算法2.4 顺序表的插入\n【算法步骤】\n① 判断插入位置i是否合法（i值的合法范围是1≤i≤n+1），若不合法则返回ERROR。\n② 判断顺序表的存储空间是否已满，若满则返回ERROR。\n③ 将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置（i&#x3D;n+1时无需移动）。\n④ 将要插入的新元素e放入第i个位置。\n⑤ 表长加1。\n顺序表插入算法的平均时间复杂度为O(n)\n5．删除\n线性表的删除操作是指将表的第i个元素删去，将长度为n的线性表\n(a1,…,ai−1,ai，ai+1,…,an)\n变成长度为n−1的线性表\n(a1,…,ai−1,ai+1,…,an)\n数据元素ai−1、ai和ai+1之间的逻辑关系发生了变化，为了在存储结构上反映这个变化，同样需要移动元素。\n顺序表删除算法的平均时间复杂度为O(n)。\n顺序表可以随机存取表中任一元素，其存储位置可用一个简单、直观的公式来表示。然而，从另一方面来看，这个特点也造成了这种存储结构的缺点：在做插入或删除操作时，需移动大量元素。另外由于数组有长度相对固定的静态特性，当表中数据元素个数较多且变化较大时，操作过程相对复杂，必然导致存储空间的浪费。\n链表：\n线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。\n为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。\n这两部分信息组成数据元素ai的存储映像，称为结点（node）。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链\nn个结点（ai（1≤i≤n）的存储映像）链结成一个链表，即为线性表(a1, a2,…, an)的链式存储结构。\n又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。\n单链表存储结构：整个链表的存取必须从头指针开始进行\n头指针指示链表中第一个结点（即第一个数据元素的存储映像，也称首元结点）的存储位置\n单链表中最后一个结点的指针为空（NULL）\n用单链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。换句话说，指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，由此，这种存储结构为非顺序映像或链式映像。\n一般情况下，为了处理方便，在单链表的第一个结点之前附设一个结点，称之为头结点\n首元结点、头结点、头指针\n（1）首元结点是指链表中存储第一个数据元素a1的结点。\n（2）头结点是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。\n（3）头指针是指向链表中第一个结点的指针。若链表设有头结点，则头指针所指结点为线性表的头结点；若链表不设头结点，则头指针所指结点为该线性表的首元结点。\n链表增加头结点的作用如下。\n（1）便于首元结点的处理增加了头结点后，首元结点的地址保存在头结点(即其“前驱”结点)的指针域中，则对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。\n（2）便于空表和非空表的统一处理当链表不设头结点时，假设L为单链表的头指针，它应该指向首元结点，则当单链表为长度n为0的空表时，L指针为空（判定空表的条件可记为：L&#x3D;&#x3D;NULL）。增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。\n单链表是非随机存取的存储结构，要取得第i个数据元素必须从头指针出发顺链进行寻找，也称为顺序存取的存取结构。\n算法2.6 \n单链表的初始化【算法步骤】\n① 生成新结点作为头结点，用头指针L指向头结点。\n② 头结点的指针域置空。\n2．取值\n和顺序表不同，链表中逻辑相邻的结点并没有存储在物理相邻的单元中，这样，根据给定的结点位置序号i，在链表中获取该结点的值不能像顺序表那样随机访问，而只能从链表的首元结点出发，顺着链域next逐个结点向下访问。\n","tags":["数据结构"]},{"title":"查找——线性表查找","url":"/2022/04/01/%E6%9F%A5%E6%89%BE/","content":"（本文所有代码都是用Java实现）\n相关术语和概态（1）查找表查找表是由同一类型的数据元素（或记录）构成的集合。（2）关键字关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为次关键字。当数据元素只有一个数据项时，其关键字即为该数据元素的值。（3）查找查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称查找成功。此时查找的结果可给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针。（4）动态查找表和静态查找表若在查找的同时对表做修改操作（如插入和删除），则相应的表称之为动态查找表，否则称之为静态查找表。（5）平均查找长度为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度（Average SearchLength，ASL）\n\n线性表的顺序查找、折半查找和分块查找。顺序查找（Sequential Search）查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。\n假设元素从ST.R[1]开始顺序向后存放，ST.R[0]闲置不用，查找时从表的最后开始比较。\n实现：\n//在顺序表中查找关键字为key的数据元素，找到则返回相应位置，否则为0    public static int searchSeq(int[] arr, int key)&#123;        for (int i = arr.length-1; i&gt;=1 ; i--) &#123;            if (arr[i]==key) return i;        &#125;        return 0;    &#125;\n\n改进：设置哨岗\n上面查找过程中每步都要检测整个表是否查找完毕，即每步都要有循环变量是否满足条件i&gt;=1的检测。改进这个程序，可以免去这个检测过程。改进方法是查找之前先对ST.R[0]的关键字赋值key，在此，ST.R[0]作为哨岗\n//改进：设置0位是哨岗 减去了数组越界的判断public static int searchSeqImprove(int[] arr, int key)&#123;    arr[0]=key;    int i;    for ( i = arr.length-1; arr[i]!=key ; i--);    return i;&#125;\n\n免去查找过程中每一步都要检测整个表是否查找完毕\n时间复杂度为O(n)\n优缺点：\n优点：算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。\n缺点：平均查找长度较大，查找效率较低，所以当n很大时，不宜采用顺序查找。\n\n折半查找&#x2F;二分查找折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。\n过程：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。\nlow和high来表示当前查找区间的下界和上界，mid为区间的中间位置\n算法描述：\n\n置查找区间初值，low为1，high为表长。\n当low小于等于high时，循环执行以下操作：\nmid取值为low和high的中间值；\n将给定值key与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置mid；\n若不相等则利用中间位置记录将表对分成前、后两个子表。如果key比中间位置记录的关键字小，则high取为mid-1，否则low取为mid+1。3.\n\n\n循环结束，说明查找区间为空，则查找失败，返回0。\n\n实现：（非递归）\n//二分查找public static int searchBin(int[] arr, int key)&#123;    int low =1;    int high = arr.length-1; //查找区间初值    while(low&lt;=high)&#123;        int mid = (low+high)/2;        if (key==arr[mid]) return mid;        else if (key&gt;mid) low=mid+1; //在前一个子表进行查找        else high=mid-1; // 在后一个子表查找    &#125;    return 0; //查找不到元素&#125;\n\n实现：(递归)\n    //二分查找 递归版    public static int searchBinRecursion(int[] arr, int key, int low, int high)&#123;        int mid =(high+low)/2;        if (key==arr[mid]) return mid; // 找到了        else if (low&gt;high) return 0; //找不到        else if (key&gt;mid) return searchBinRecursion(arr,key,mid+1,high);//在前一个子表进行查找        else return searchBinRecursion(arr,key,low,mid-1);// 在后一个子表查找    &#125;//main函数使用int result =  searchBinRecursion(arr,9,arr[1],arr.length-1);        System.out.println(&quot;result: &quot;+result);\n\n\n\n注意：循环执行的条件是low&lt;&#x3D;high，而不是low&lt;high，因为low&#x3D;high时，查找区间还有最后一个结点，还要进一步比较\n折半查找过程可用二叉树来描述，树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号，把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的判定树。\n折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度。而判定树的形态只与表记录个数n相关，而与关键字的取值无关，具有n个结点的判定树的深度为\n所以，对于长度为n的有序表，折半查找法在查找成功时和给定值进行比较的关键字个数至多为\n时间复杂度为O(log2n )\n优缺点：\n优点：比较次数少，查找效率高。\n缺点：对表结构要求高，只能用于顺序存储的有序表。为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素。折半查找不适用于数据元素经常变动的线性表。\n\n分块查找&#x2F;索引顺序查找除表本身以外，尚需建立一个“索引表”\n\n如图表有18个记录，可分为3个子表，对每个子表（或称块）建立一个索引项，其中包括两项内容：关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中位置）\n索引表按关键字有序，则表或者有序或者分块有序（第二个子表中所有记录的关键字均大于第一个子表中的最大关键字（22））\n分块查找分两步进行：\n\n先确定待查记录所在的块（子表）\n例如key&#x3D;38，将key与索引表中各个最大关键字进行比较，22&lt;38&lt;48，所以如果38存在就是在第二个子表中。\n\n在块中顺序查找\n由于同一索引项中的指针指示第二个子表中的第一个记录是表中第7个记录，则自第7个记录起进行顺序查找，直到找到结束。如果没有关键字等于key，查找不成功。\n\n\n分块查找的平均查找长度\n\n\n\n优缺点：\n优点：在表中插入和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。\n缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算。\n参考：数据结构（C语言版）（第2版）\n","tags":["数据结构"]}]